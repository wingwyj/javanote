## Java 分布式编程  
### 常见分布式ID生成方案
   * `UUID` 通用唯一识别码，字符串太长，无业务含义，存储性能差，实际项目中用的不多。  
   * `基于数据库自增id` 基于`auto_increment`每次插入时返回自增id，实现简单，但是单点有宕机且难扛住分布式高并发场景。
   * `数据库集群模式` 是对单点数据库宕机的优化，采用主从模式，给数据库自增id设置起始值和自增步长，解决单点宕机风险，但是单个数据库的高并发场景压力依旧很大。  
   * `数据库号段模式` 每次从数据库取一段id值，用完再取，减少数据库请求次数，解决高并发数据库瓶颈。
   * `Redis方式` 基于redis的`incr`命令也可以实现。考虑Redis的持久化问题，RDB定时打快照方式持久化重启会有数据丢失情况，导致ID重复；AOF每条修改指令都记录，不会ID重复，重启恢复数据时间过长。  
   * `Snowflake(雪花算法)模式` Twitter开源的分布式ID生成方案，备受国内大厂关注。  
   * `uid-generator（百度）` 百度基于snowflake开发的分布式ID生成方案。  
   * `Leaf(美团)` Leaf同时支持号段模式和snowflake算法模式，可以切换使用。  
   * `Tinyid(滴滴)` Tinyid是滴滴基于号段模式开发的分布式ID生成方案。  
   详解常用 `基于数据库号段模式` 和 `Snowflake(雪花算法)模式`  
   > **基于数据库的号段模式**
   > > `号段模式` 是当下分布式ID生成器的主流实现方式之一。 号段模式每次取出一定范围的号段，加载到内存中，给具体的服务使用。  
   > > ```sql
   > > CREATE TABLE id_generator (
   > > id int(10) NOT NULL,
   > > max_id bigint(20) NOT NULL COMMENT '当前最大id',
   > > step int(20) NOT NULL COMMENT '号段的步长',
   > > biz_type	int(20) NOT NULL COMMENT '业务类型',
   > > version int(20) NOT NULL COMMENT '版本号',
   > > PRIMARY KEY (`id`)
   > > )
   > > ```  
   > > version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性。等这批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]。由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。
   >  
   > **基于Snowflake(雪花算法)**  
   > > `雪花算法` 生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。
   > > Snowflake ID组成结构：`正数位`（占1比特）+ `时间戳`（占41比特）+ `机器ID`（占5比特）+ `数据中心`（占5比特）+ `自增值`（占12比特），总共64比特组成的一个Long类型。  
   > > * 第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。  
   > > * 时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69年。  
   > > * 工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。  
   > > 序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID。  
   > 
   > [参考文章](https://zhuanlan.zhihu.com/p/107939861)
